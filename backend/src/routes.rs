use std::collections::HashSet;

use anyhow::Result;
use geo::{Haversine, Length, LineString};
use geojson::{Feature, FeatureCollection, Geometry};
use graph::{Graph, PathStep, Position, RoadID};
use serde::{Deserialize, Serialize};

use crate::join_lines::KeyedLineString;
use crate::route_snapper::roads_to_waypoints;
use crate::{
    level_of_service::get_level_of_service, utils::into_object_value, Highway, InfraType,
    LevelOfService, MapModel, Tier, TrafficVolume,
};

#[derive(Clone)]
pub struct InMemoryRoute {
    // The input used to determine geometry. These waypoints are the snapped positions, already
    // accounting for things like preferring major roads.
    pub waypoints_wgs84: Vec<Waypoint>,

    // The geometry generated by the input
    pub linestring_wgs84: LineString,

    // A semantic version of the geometry, derived only from the input
    pub roads: Vec<(RoadID, Dir)>,

    // Metadata about the route
    pub name: String,
    pub notes: String,
    pub infra_type: InfraType,
    pub override_infra_type: bool,
    pub tier: Tier,
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct Waypoint {
    pub point: [f64; 2],
    pub snapped: bool,
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum Dir {
    Forwards,
    Backwards,
}

#[derive(Serialize, Deserialize)]
pub struct SavedRoute {
    // WGS84
    #[serde(
        serialize_with = "geojson::ser::serialize_geometry",
        deserialize_with = "geojson::de::deserialize_geometry"
    )]
    geometry: LineString,

    pub id: usize,
    waypoints: Vec<Waypoint>,

    name: String,
    notes: String,
    infra_type: InfraType,
    override_infra_type: bool,
    tier: Tier,
}

/// Just the props, no linestring and no ID. The _intention_ is that this'll get auto split up to
/// actually create routes.
#[derive(Serialize, Deserialize)]
pub struct SetRouteInput {
    // WGS84 when deserialized, then transformed to Mercator in the WASM layer
    pub waypoints: Vec<Waypoint>,

    pub name: String,
    pub notes: String,
    pub infra_type: InfraType,
    pub override_infra_type: bool,
    pub tier: Tier,
}

impl MapModel {
    /// Returns a list of route IDs in order (but there may be gaps for existing routes)
    pub fn set_route(
        &mut self,
        edit_id: Option<usize>,
        orig_route: SetRouteInput,
    ) -> Result<Vec<usize>> {
        // The waypoints should already be corrected to the exact snapped positions
        let major_snap_threshold = None;
        let (orig_roads, _) = self.waypoints_to_path(&orig_route.waypoints, major_snap_threshold);

        // If we're editing an existing route, first delete it
        if let Some(id) = edit_id {
            if self.routes.remove(&id).is_none() {
                bail!("Unknown route {id}");
            }
        }

        let used_roads = self.used_roads();

        // This is deliberately separate from autosplit_route, which splits by more categories
        //
        // Split when:
        // - the auto-recommended infrastructure type changes (unless manually overriden)
        // - the route crosses something existing
        // - the infrastructure type does or does not fit in the available streetspace
        // - the level of service changes
        // - the tier changes (based on whether the road is inside a settlement or not)
        #[derive(PartialEq)]
        enum Case {
            AlreadyExists,
            New {
                infra_type: InfraType,
                fits: bool,
                los: LevelOfService,
                tier: Tier,
            },
        }
        let case = |(r, _)| {
            if used_roads.contains(&r) {
                Case::AlreadyExists
            } else {
                let infra_type = if orig_route.override_infra_type {
                    orig_route.infra_type
                } else {
                    self.best_infra_type(r)
                };
                let los = get_level_of_service(
                    infra_type,
                    self.speeds[r.0],
                    self.traffic_volumes[r.0],
                    self.within_settlement[r.0],
                );

                Case::New {
                    infra_type,
                    fits: self.does_infra_type_fit(r, infra_type),
                    los,
                    tier: fix_tier_drawing(
                        orig_route.tier,
                        self.within_settlement[r.0],
                        self.highways[r.0],
                    ),
                }
            }
        };

        let mut new_routes = Vec::new();
        for roads in orig_roads.chunk_by(|a, b| case(*a) == case(*b)) {
            let (infra_type, tier) = match case(roads[0]) {
                Case::AlreadyExists => {
                    // TODO Should we modify that route and add to its notes or description? What
                    // if the tier or something else differs?
                    continue;
                }
                Case::New {
                    infra_type, tier, ..
                } => (infra_type, tier),
            };

            let linestring_wgs84 = glue_route_wgs84(&self.graph, roads);
            let waypoints_wgs84 = roads_to_waypoints(&self.graph, roads);

            new_routes.push(InMemoryRoute {
                waypoints_wgs84,

                linestring_wgs84,

                roads: roads.to_vec(),

                name: orig_route.name.clone(),
                notes: orig_route.notes.clone(),
                infra_type,
                override_infra_type: orig_route.override_infra_type,
                tier,
            });
        }

        let mut new_ids = Vec::new();
        for route in new_routes {
            let route_id = self.id_counter;
            self.id_counter += 1;
            self.routes.insert(route_id, route);
            new_ids.push(route_id);
        }
        self.recalculate_after_edits();

        Ok(new_ids)
    }

    pub fn delete_routes(&mut self, ids: Vec<usize>) -> Result<()> {
        for id in ids {
            if !self.routes.remove(&id).is_some() {
                bail!("Unknown route {id}");
            }
        }
        self.recalculate_after_edits();
        return Ok(());
    }

    pub fn clear_all_routes(&mut self) {
        self.routes.clear();
        self.id_counter = 0;
        self.recalculate_after_edits();
    }

    /// This is also the format used for savefiles
    pub fn get_all_routes(&self) -> FeatureCollection {
        FeatureCollection {
            features: self
                .routes
                .iter()
                .map(|(id, r)| r.to_gj(*id))
                .collect::<Vec<_>>(),
            bbox: None,
            foreign_members: Some(into_object_value(serde_json::json!({
                "id_counter": self.id_counter,
                "version": 2,
                "study_area_name": self.study_area_name.clone(),
            }))),
        }
    }

    pub fn get_route(&self, id: usize) -> Result<Feature> {
        let Some(route) = self.routes.get(&id) else {
            bail!("No route {id}");
        };
        Ok(route.to_gj(id))
    }

    fn tier_for_import(&self, r: RoadID) -> Tier {
        if !self.within_settlement[r.0] {
            return Tier::LongDistance;
        }
        if self.precalculated_demands[r.0] >= self.high_demand_threshold {
            Tier::Primary
        } else if self.precalculated_demands[r.0] >= self.medium_demand_threshold {
            Tier::Secondary
        } else {
            Tier::LocalAccess
        }
    }

    pub fn import_existing_routes(&mut self, only_some_infra_types: bool) {
        let used_roads = self.used_roads();
        let mut imports = Vec::new();
        for (idx, road) in self.graph.roads.iter().enumerate() {
            let road_id = RoadID(idx);
            if used_roads.contains(&road_id) {
                continue;
            }
            let Some(infra_type) =
                crate::existing::classify_existing_osm_infra(self.is_offroad[idx], &road.osm_tags)
            else {
                continue;
            };

            if only_some_infra_types {
                if !matches!(infra_type, InfraType::Segregated | InfraType::OffRoad) {
                    continue;
                }
            } else {
                // We could check if the current LoS is already high, but if it is, it may be
                // because it's an existing separately tagged cycleway that has no modelled traffic
                // volume.
                if get_level_of_service(
                    infra_type,
                    self.speeds[idx],
                    self.traffic_volumes[idx],
                    self.within_settlement[idx],
                ) != LevelOfService::High
                {
                    continue;
                }
                // Always skip footways. The user can trace over these if desired.
                if infra_type == InfraType::SharedFootway {
                    continue;
                }
            }

            imports.push((road_id, infra_type, self.tier_for_import(road_id)));
        }

        self.import_roads(imports);
    }

    pub fn import_arterial_roads(&mut self) {
        let used_roads = self.used_roads();
        let mut imports = Vec::new();

        for idx in 0..self.graph.roads.len() {
            let road_id = RoadID(idx);
            if used_roads.contains(&road_id) {
                continue;
            }
            if self.highways[idx].is_arterial_road() {
                imports.push((
                    road_id,
                    self.best_infra_type(road_id),
                    self.tier_for_import(road_id),
                ));
            }
        }

        self.import_roads(imports);
    }

    /// Split a route into sections, returning a FeatureCollection & SseDetails
    pub fn autosplit_route(
        &self,
        editing_route_id: Option<usize>,
        waypoints: Vec<Waypoint>,
        override_infra_type: Option<InfraType>,
        default_tier: Tier,
        major_snap_threshold: Option<f64>,
    ) -> Result<Vec<u8>> {
        let mut used_roads = self.used_roads();
        if let Some(id) = editing_route_id {
            for (r, _) in &self.routes[&id].roads {
                used_roads.remove(r);
            }
        }

        let (route_roads, _) = self.waypoints_to_path(&waypoints, major_snap_threshold);

        // Split when:
        // - the auto-recommended or manual infrastructure type changes
        // - the route crosses something existing (except the existing route)
        // - the infrastructure type does or does not fit in the available streetspace
        // - the gradient group changes
        // - the level of service changes
        // - the tier changes (based on whether the road is inside a settlement or not)
        #[derive(PartialEq)]
        enum Case {
            AlreadyExists {
                gradient: &'static str,
                los: LevelOfService,
                tier: Tier,
            },
            New {
                infra_type: InfraType,
                fits: bool,
                gradient: &'static str,
                los: LevelOfService,
                tier: Tier,
            },
        }
        let case = |(r, _): (RoadID, _)| {
            let gradient = gradient_group(self.gradients[r.0]);
            if used_roads.contains(&r) {
                Case::AlreadyExists {
                    gradient,
                    los: self.los[r.0],
                    tier: self.tiers[r.0].unwrap(),
                }
            } else {
                let infra_type = override_infra_type.unwrap_or_else(|| self.best_infra_type(r));
                let los = get_level_of_service(
                    infra_type,
                    self.speeds[r.0],
                    self.traffic_volumes[r.0],
                    self.within_settlement[r.0],
                );
                let tier = fix_tier_drawing(
                    default_tier,
                    self.within_settlement[r.0],
                    self.highways[r.0],
                );
                Case::New {
                    infra_type,
                    fits: self.does_infra_type_fit(r, infra_type),
                    gradient,
                    los,
                    tier,
                }
            }
        };

        let mut sse_details = SseDetails::default();
        // Dummy placeholder value
        sse_details.min_e2e_width = 100;
        let mut los_details = Vec::new();

        let mut sections = Vec::new();
        for roads in route_roads.chunk_by(|a, b| case(*a) == case(*b)) {
            let c = case(roads[0]);

            let (common_infra_type, common_los) = match c {
                Case::AlreadyExists { los, .. } => (None, los),
                Case::New {
                    infra_type, los, ..
                } => (Some(infra_type), los),
            };

            for (r, _) in roads {
                sse_details.update(self, *r);
                los_details.push(LevelOfServiceDetails {
                    speed: self.speeds[r.0],
                    traffic: self.traffic_volumes[r.0],
                    // An existing route will have something filled out here
                    infra_type: common_infra_type.or(self.infra_types[r.0]).unwrap(),
                    los: common_los,
                });
            }

            let linestring_wgs84 = glue_route_wgs84(&self.graph, roads);
            let mut f = Feature::from(Geometry::from(&linestring_wgs84));
            match c {
                Case::AlreadyExists {
                    gradient,
                    los,
                    tier,
                } => {
                    f.set_property("infra_type", "overlap");
                    f.set_property("fits", true);
                    f.set_property("gradient_group", gradient);
                    f.set_property("los", serde_json::to_value(&los).unwrap());
                    f.set_property("tier", serde_json::to_value(&tier).unwrap());
                }
                Case::New {
                    infra_type,
                    fits,
                    gradient,
                    los,
                    tier,
                } => {
                    f.set_property("infra_type", serde_json::to_value(&infra_type).unwrap());
                    f.set_property("fits", fits);
                    f.set_property("gradient_group", gradient);
                    f.set_property("los", serde_json::to_value(&los).unwrap());
                    f.set_property("tier", serde_json::to_value(&tier).unwrap());
                }
            }
            f.set_property("length", Haversine.length(&linestring_wgs84));
            sections.push(f);
        }

        if sse_details.min_e2e_width == 100 {
            sse_details.min_e2e_width = 0;
        }
        sse_details.cross_section_profiles.sort();
        sse_details.cross_section_profiles.dedup();
        los_details.dedup();
        sse_details.los_details = los_details;

        Ok(serde_json::to_vec(&FeatureCollection {
            features: sections,
            bbox: None,
            foreign_members: Some(into_object_value(serde_json::to_value(&sse_details)?)),
        })?)
    }

    pub fn preview_route(
        &self,
        waypoints: Vec<Waypoint>,
        major_snap_threshold: Option<f64>,
    ) -> Result<Vec<u8>> {
        let (_, linestring) = self.waypoints_to_path(&waypoints, major_snap_threshold);
        let f = self.graph.mercator.to_wgs84_gj(&linestring);
        Ok(serde_json::to_vec(&f)?)
    }

    pub fn change_tier(&mut self, route_ids: Vec<usize>, tier: Tier) -> Result<()> {
        for id in route_ids {
            if let Some(route) = self.routes.get_mut(&id) {
                route.tier = tier;
            } else {
                bail!("Unknown route {id}");
            }
        }
        self.recalculate_after_edits();
        Ok(())
    }

    pub fn change_infra_type(
        &mut self,
        route_ids: Vec<usize>,
        infra_type: InfraType,
    ) -> Result<()> {
        for id in route_ids {
            if let Some(route) = self.routes.get_mut(&id) {
                if route.infra_type != infra_type {
                    route.infra_type = infra_type;
                    route.override_infra_type = true;
                }
            } else {
                bail!("Unknown route {id}");
            }
        }
        self.recalculate_after_edits();
        Ok(())
    }

    pub fn get_route_sections(&self, ids: Vec<usize>) -> Result<Vec<u8>> {
        let mut sections = Vec::new();
        for id in ids {
            let Some(route) = self.routes.get(&id) else {
                bail!("No route {id}");
            };

            // We assume fits and los are uniform for all roads in the route; everything that sets
            // or imports routes must maintain this invariant
            let (r, _) = route.roads[0];
            let fits = self.does_infra_type_fit(r, route.infra_type);
            let los = get_level_of_service(
                route.infra_type,
                self.speeds[r.0],
                self.traffic_volumes[r.0],
                self.within_settlement[r.0],
            );
            sections.push(RouteSection {
                id,
                tier: route.tier,
                infra_type: route.infra_type,
                fits,
                los,
            });
        }
        Ok(serde_json::to_vec(&sections)?)
    }

    fn import_roads(&mut self, imports: Vec<(RoadID, InfraType, Tier)>) {
        let used_roads = self.used_roads();

        // Create individual segments to import
        let mut pieces = Vec::new();
        for (r, infra_type, tier) in imports {
            // Don't overwrite anything existing (relevant when importing multiple layers)
            if used_roads.contains(&r) {
                continue;
            }

            let fits = self.does_infra_type_fit(r, infra_type);
            let los = get_level_of_service(
                infra_type,
                self.speeds[r.0],
                self.traffic_volumes[r.0],
                self.within_settlement[r.0],
            );

            pieces.push(KeyedLineString {
                linestring: self.graph.roads[r.0].linestring.clone(),
                ids: vec![(r, Dir::Forwards)],
                key: (infra_type, tier, fits, los),
            });
        }

        // Group them in hopefully meaningful chunks
        // TODO Could try more aggressive joining after this, but this one seems to work fine so
        // far. Although oddly it seems to handle more than just degree 2...
        pieces = crate::join_lines::collapse_degree_2(pieces);

        for line in pieces {
            let (infra_type, tier, _, _) = line.key;

            let linestring_wgs84 = self.graph.mercator.to_wgs84(&line.linestring);
            let waypoints_wgs84 = roads_to_waypoints(&self.graph, &line.ids);

            // Pick the first name
            // TODO Does this short-circuit?
            let name = line
                .ids
                .iter()
                .filter_map(|(r, _)| self.graph.roads[r.0].osm_tags.get("name").cloned())
                .next()
                .unwrap_or_else(String::new);

            let route = InMemoryRoute {
                waypoints_wgs84,

                linestring_wgs84,

                roads: line.ids,

                name,
                notes: "imported from existing network".to_string(),
                infra_type,
                override_infra_type: false,
                tier,
            };
            let route_id = self.id_counter;
            self.id_counter += 1;
            self.routes.insert(route_id, route);
        }

        self.recalculate_after_edits();
    }

    fn used_roads(&self) -> HashSet<RoadID> {
        self.routes
            .values()
            .flat_map(|route| route.roads.iter().map(|(r, _)| *r))
            .collect()
    }
}

// TODO Upstream to graph
pub fn glue_route_wgs84(graph: &Graph, roads: &[(RoadID, Dir)]) -> LineString {
    let route = graph::Route {
        start: start_pos(roads[0], graph),
        end: end_pos(*roads.last().unwrap(), graph),
        steps: roads
            .into_iter()
            .cloned()
            .map(|(road, dir)| PathStep::Road {
                road,
                forwards: matches!(dir, Dir::Forwards),
            })
            .collect(),
    };
    graph.mercator.to_wgs84(&route.linestring(graph))
}

// TODO Upstream to graph
pub fn start_pos((r, dir): (RoadID, Dir), graph: &Graph) -> Position {
    let road = &graph.roads[r.0];
    Position {
        road: r,
        fraction_along: if matches!(dir, Dir::Forwards) {
            0.0
        } else {
            1.0
        },
        intersection: if matches!(dir, Dir::Forwards) {
            road.src_i
        } else {
            road.dst_i
        },
    }
}

pub fn end_pos((road, dir): (RoadID, Dir), graph: &Graph) -> Position {
    let opposite = match dir {
        Dir::Forwards => Dir::Backwards,
        Dir::Backwards => Dir::Forwards,
    };
    start_pos((road, opposite), graph)
}

impl InMemoryRoute {
    fn to_gj(&self, id: usize) -> Feature {
        geojson::ser::to_feature(SavedRoute {
            geometry: self.linestring_wgs84.clone(),
            id,
            waypoints: self.waypoints_wgs84.clone(),

            name: self.name.clone(),
            notes: self.notes.clone(),
            infra_type: self.infra_type,
            override_infra_type: self.override_infra_type,
            tier: self.tier,
        })
        .unwrap()
    }
}

impl SavedRoute {
    // This assumes the one saved route will wind up being one InMemoryRoute. If the underlying OSM
    // MapModel changes over time, maybe one saved route needs to get split.
    pub fn to_in_memory(self, model: &MapModel) -> InMemoryRoute {
        let waypoints = self
            .waypoints
            .iter()
            .map(|w| Waypoint {
                snapped: w.snapped,
                point: model.graph.mercator.pt_to_mercator(w.point.into()).into(),
            })
            .collect();

        // The waypoints should already be corrected to the exact snapped positions
        let major_snap_threshold = None;
        let (roads, _) = model.waypoints_to_path(&waypoints, major_snap_threshold);
        InMemoryRoute {
            waypoints_wgs84: self.waypoints,

            linestring_wgs84: self.geometry,

            roads,

            name: self.name,
            notes: self.notes,
            infra_type: self.infra_type,
            override_infra_type: self.override_infra_type,
            tier: self.tier,
        }
    }
}

pub fn gradient_group(gradient: f64) -> &'static str {
    let g = gradient.abs();
    if g <= 3.0 {
        "<= 3%"
    } else if g <= 5.0 {
        "3 - 5%"
    } else if g <= 7.0 {
        "5 - 7%"
    } else if g <= 10.0 {
        "7 - 10%"
    } else {
        "> 10%"
    }
}

fn fix_tier_drawing(default: Tier, within_settlement: bool, highway: Highway) -> Tier {
    if within_settlement {
        if default != Tier::LongDistance {
            return default;
        }
        // If the user is drawing a long-distance route and enters a settlement, then override the
        // tier to primary for arterial roads and local access otherwise
        return if highway.is_arterial_road() {
            Tier::Primary
        } else {
            Tier::LocalAccess
        };
    }

    // If we're outside a settlement, force LongDistance
    Tier::LongDistance
}

#[derive(Serialize)]
struct RouteSection {
    id: usize,
    tier: Tier,
    infra_type: InfraType,
    fits: bool,
    los: LevelOfService,
}

#[derive(Default, Serialize)]
struct SseDetails {
    some_roads_without_sse: bool,
    min_e2e_width: usize,
    max_e2e_width: usize,
    cross_section_profiles: Vec<String>,

    los_details: Vec<LevelOfServiceDetails>,
}

impl SseDetails {
    fn update(&mut self, map: &MapModel, r: RoadID) {
        let Some(ref ss) = map.street_space[r.0] else {
            self.some_roads_without_sse = true;
            return;
        };

        self.min_e2e_width = self.min_e2e_width.min(ss.edge_to_edge_width);
        self.max_e2e_width = self.max_e2e_width.max(ss.edge_to_edge_width);
        self.cross_section_profiles
            .push(ss.cross_section_profile.clone());
    }
}

#[derive(PartialEq, Serialize)]
struct LevelOfServiceDetails {
    speed: usize,
    traffic: TrafficVolume,
    infra_type: InfraType,
    los: LevelOfService,
}
